#include "pargen/include/parser/lexer.h"
#include "pargen/include/parser/error.h"
#include "utils/include/string/kev_string.h"

#include <stdlib.h>
$r transition-table $:$;

$r start-state $:$;

$r pattern-mapping $:$;

$r info-array $:$;

typedef void Callback(KevPLexer* lex);

$r callback-array $:$;

static char* kev_get_escape_str(const char* str, size_t len);


void kev_plex_simple_id(KevPLexer* lex) {
  KevPToken* token = &lex->currtoken;
  if (!(token->attr.str = kev_str_copy_len((char*)lex->buf, token->end - token->begin))) {
    kev_parser_throw_error(stderr, lex->infile, token->begin, "out of memory", NULL);
    lex->err_count++;
  }
}

void kev_plex_str_id(KevPLexer* lex) {
  KevPToken* token = &lex->currtoken;
  if (!(token->attr.str = kev_get_escape_str((char*)lex->buf + 1, token->end - token->begin - 1))) {
    kev_parser_throw_error(stderr, lex->infile, token->begin, "out of memory", NULL);
    lex->err_count++;
  }
}

void kev_plex_str(KevPLexer* lex) {
  KevPToken* token = &lex->currtoken;
  if (!(token->attr.str = kev_get_escape_str((char*)lex->buf + 1, token->end - token->begin - 1))) {
    kev_parser_throw_error(stderr, lex->infile, token->begin, "out of memory", NULL);
    lex->err_count++;
  }
}

void kev_plex_simple_str(KevPLexer* lex) {
  KevPToken* token = &lex->currtoken;
  if (!(token->attr.str = kev_str_copy_len((char*)lex->buf + 1, token->end - token->begin - 2))) {
    kev_parser_throw_error(stderr, lex->infile, token->begin, "out of memory", NULL);
    lex->err_count++;
  }
}

void kev_plex_num(KevPLexer* lex) {
  KevPToken* token = &lex->currtoken;
  if (!(token->attr.num = strtol((char*)lex->buf, NULL, 10))) {
    kev_parser_throw_error(stderr, lex->infile, token->begin, "out of memory", NULL);
    lex->err_count++;
  }
}

void kev_plex_err(KevPLexer* lex) {
  KevPToken* token = &lex->currtoken;
  kev_parser_throw_error(stderr, lex->infile, token->begin, "lexical error", NULL);
  lex->err_count++;
  lex->currpos++;
  FILE* infile = lex->infile;
  uint8_t (*table)[256] = lex->table;
  uint8_t* buf = lex->buf;
  size_t tokenlen = 0;
  uint8_t state = lex->start;
  do {
    state = lex->start;
    uint8_t next_state = 0;
    uint8_t ch = (uint8_t)fgetc(infile);
    tokenlen = 0;
    while ((next_state = table[state][ch]) != KEV_PLEX_DEAD && tokenlen < KEV_PLEX_BUF_SIZE) {
      buf[tokenlen++] = ch;
      state = next_state;
      ch = (uint8_t)fgetc(infile);
    }
    ungetc(ch, infile);
    lex->currpos += tokenlen;
    if (tokenlen == 0) {
      fgetc(infile);
      lex->currpos++;
    }
  } while (lex->pattern_mapping[state] == KEV_PLEX_NONACC);

  token->begin = lex->currpos - tokenlen;
  token->end = lex->currpos;
  token->kind = lex->pattern_mapping[state];
  if (lex->callbacks[state]) {
    lex->callbacks[state](lex);
  }
}

static char* kev_get_escape_str(const char* origin, size_t len) {
  char* str = NULL;
  str = (char*)malloc(sizeof (char) * (len + 1));
  size_t i = 0;
  if (!str) return NULL;
  const char* endptr = origin + len;
  while (origin != endptr) {
    if (*origin == '\\') {
      switch (*++origin) {
        case 'n': str[i++] = '\n'; break;
        case 'r': str[i++] = '\r'; break;
        case 't': str[i++] = '\t'; break;
        case '\'': str[i++] = '\''; break;
        case '\"': str[i++] = '\"'; break;
        case '\\': str[i++] = '\\'; break;
        default: str[i++] = *origin; break;
      }
    } else {
      str[i++] = *origin;
    }
    origin++;
  }
  str[i] = '\0';
  return str;
}
