import env-res .. opt-language;

decl t: num , cos, sin, exp, ln, '+', '-', '*', '/', '(', ')', '$';
decl n: expr;

expr : expr '+' expr  ` $0 = $1 + $3; `
     | expr '-' expr  ` $0 = $1 - $3; `
     | expr '*' expr  ` $0 = $1 * $3; `
     | expr '/' expr  ` $0 = $1 / $3; `
     | cos expr       ` $0 = cos($2); `
     | sin expr       ` $0 = sin($2); `
     | exp expr       ` $0 = exp($2); `
     | ln  expr       ` $0 = log($2); `
     | '+' expr       ` $0 = $2; `
     | '-' expr       ` $0 = - $2; `
     | '(' expr ')'   ` $0 = $2; `
     | num            ` $0 = $1; `
     ;

#set start and end symbol
set start expr;
set end '$';
#set prority to handle ambiguity
set prio '+'(post) = '-'(post) < '+' = '-' < '*'(post) = '/'(post) < '*' = '/' <;
set prio '+'(pre) = '-'(pre) = cos(pre) = sin(pre) = exp(pre) = ln(pre);
#set conflict handler
set con priority, log : "expr.log";

#define attribute type
%attr-definition = "float";

#a series of statements that read next token
%lexer-token-next = `lex_next(input);`;

%lexer-init = lexer-token-next;

#an expression whose value is the id of the current token
%lexer-token-id-expr = `token_id`;

#a series of statements that convert attribute of current token to attribute of syntax symbol
#the result is stored in predefined variable 'attr'
%lexer-token-convert-attr = `attr = attrval;`;

#this will be placed at the beginning of the entire file
%source-pre = `
#include <ctype.h>
#include <math.h>
#include <string.h>

static int token_id = 0;
static float attrval = 0.0;
void lex_next(FILE* stream);
`;

#this will be placed at the end of the entire file
%source-post = `
void lex_next(FILE* stream) {
  int ch = fgetc(stream);
  while (ch == ' ' || ch == '\t')
    ch = fgetc(stream);
  if (isdigit(ch)) {
    ungetc(ch, stream);
    fscanf(stream, "%f", &attrval);
    token_id = ` .. idof (num) .. `;
  } else if (isalpha(ch)) {
    char buf[4];
    int i = 0;
    buf[i++] = ch;
    while (isalpha(ch = fgetc(stream)) && i < 3)
      buf[i++] = ch;
    buf[i] = '\0';
    ungetc(ch, stream);
    if (strcmp(buf, "cos") == 0) {
      token_id = ` .. idof (cos) .. `;
    } else if (strcmp(buf, "sin") == 0) {
      token_id = ` .. idof (sin) .. `;
    } else if (strcmp(buf, "exp") == 0) {
      token_id = ` .. idof (exp) .. `;
    } else if (strcmp(buf, "ln") == 0) {
      token_id = ` .. idof (ln) .. `;
    } else {
      fprintf(stderr, "lexical error\n");
      lex_next(stream);
    }
  } else if (ch == '+') {
    token_id = ` .. idof ('+') .. `;
  } else if (ch == '-') {
    token_id = ` .. idof ('-') .. `;
  } else if (ch == '*') {
    token_id = ` .. idof ('*') .. `;
  } else if (ch == '/') {
    token_id = ` .. idof ('/') .. `;
  } else if (ch == '(') {
    token_id = ` .. idof ('(') .. `;
  } else if (ch == ')') {
    token_id = ` .. idof (')') .. `;
  } else if (ch == EOF || ch == '\n') {
    token_id = ` .. idof ('$') .. `;
  } else {
    fprintf(stderr, "lexical error\n");
    lex_next(stream);
  }
}

int main(int argc, char** argv) {
  while (true) {
    printf(">>>");
    float result = parse(stdin);
    printf("%f\n", result);
  }
  return 0;
}`;
